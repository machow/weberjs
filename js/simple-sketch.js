// Generated by CoffeeScript 1.9.2
(function() {
  var Sketcher, p, path, points, sketch, textItem, toolDraw,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    hasProp = {}.hasOwnProperty;

  view.size = [500, 500];

  Sketcher = (function() {
    function Sketcher(options) {
      this.id = options.id, this.key = options.key;
      this.history = [];
      this.current = {
        group: null,
        item: null
      };
      this.buffer = [];
      this.state;
      this.start = Date.now();
      this.style = {};
    }

    Sketcher.prototype.draw = function(seg) {
      var p, path, points, time;
      points = seg.points, time = seg.time;
      path = new Path((function() {
        var i, len, results;
        results = [];
        for (i = 0, len = points.length; i < len; i++) {
          p = points[i];
          results.push(new Point(p[0], p[1]));
        }
        return results;
      })());
      path.strokeColor = 'black';
      this.history.push(path);
      return path;
    };

    Sketcher.prototype.regTimed = function(seg, relTime) {
      var crnt_ii, drawTime, path, points, t, time;
      points = seg.points, time = seg.time;
      if (relTime == null) {
        relTime = time[0];
      }
      drawTime = (function() {
        var i, len, results;
        results = [];
        for (i = 0, len = time.length; i < len; i++) {
          t = time[i];
          results.push(Date.now() + t - relTime);
        }
        return results;
      })();
      crnt_ii = 0;
      console.log(drawTime);
      path = new Path();
      return this.buffer.push(function(crntTime) {
        var a, p;
        while (drawTime[crnt_ii] < crntTime) {
          p = points[crnt_ii];
          path.add(new Point(p[0], p[1]));
          crnt_ii += 1;
          console.log(new Point(p[0], p[1]));
          console.log((function() {
            var i, len, results;
            results = [];
            for (i = 0, len = drawTime.length; i < len; i++) {
              a = drawTime[i];
              results.push(a < crntTime);
            }
            return results;
          })());
        }
        return crnt_ii;
      });
    };

    Sketcher.prototype.drawTimed = function(time) {
      var f, i, len, ref;
      ref = this.buffer;
      for (i = 0, len = ref.length; i < len; i++) {
        f = ref[i];
        f(time);
      }
      return null;
    };

    Sketcher.prototype.toggle = function(state) {
      if (indexOf.call(state, 'draw') >= 0) {
        return state.draw;
      }
    };

    Sketcher.prototype.newPath = function(cnfg) {
      var k, path, ref, v;
      ref = this.style;
      for (k in ref) {
        if (!hasProp.call(ref, k)) continue;
        v = ref[k];
        if (indexOf.call(cnfg, k) < 0) {
          cnfg[k] = v;
        }
      }
      this.current.group.addChild(path = new Path(cnfg));
      return path;
    };

    Sketcher.prototype.endPath = function(path) {
      return this.history.push(pathToData(path));
    };

    Sketcher.prototype.pathToData = function(path) {
      var data, i, len, ref, seg;
      data = {
        points: [],
        time: []
      };
      ref = path._segments;
      for (i = 0, len = ref.length; i < len; i++) {
        seg = ref[i];
        data.points.push([seg.point.x, seg.point.y]);
        data.time.push(seg.point._time);
      }
      data.name = path.name;
      data.group = path.group;
      return data;
    };

    Sketcher.prototype.timeFromStart = function(restart) {
      if (restart == null) {
        this.start = Date.now();
        return 0;
      }
      return Date.now() - this.start;
    };


    /*
     * TOOLS
     */

    Sketcher.tools = {};

    Sketcher.tools.draw = new Tool();

    Sketcher.tools.draw.onMouseDown = function(event) {
      var path;
      path = new Path({
        segments: [event.point],
        strokeColor: 'black'
      });
      return path._segments[0]._time = this.timeFromeStart();
    };

    Sketcher.tools.draw.onMouseDrag = function(event) {
      var segmentCount;
      path.add(event.point);
      segmentCount = path.segments.length;
      return textItem.content = segmentCount + " points";
    };

    Sketcher.tools.draw.onMouseUp = function(event) {
      var segmentCount;
      segmentCount = path.segments.length;
      return textItem.content = segmentCount + " points";
    };

    return Sketcher;

  })();

  sketch = new Sketcher({
    id: 'abc',
    key: 123
  });

  path = null;

  textItem = new PointText({
    content: '',
    point: new Point(20, 30),
    fillColor: 'black'
  });

  toolDraw = new Tool();

  toolDraw.activate();

  sketch.regTimed({
    points: [[100, 200], [200, 300], [300, 400]],
    time: [1000, 2000, 5000]
  });

  points = (function() {
    var i, len, ref, results;
    ref = [[100, 200], [300, 500]];
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      p = ref[i];
      results.push(new Point(p[0], p[1]));
    }
    return results;
  })();

  path = new Path(points);

  path.strokeColor = 'black';

  window.path = path;

  window.tool = tool;

}).call(this);
